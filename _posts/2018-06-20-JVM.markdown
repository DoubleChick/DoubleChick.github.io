---
layout:     post
title:      "JVM小记(一)"
subtitle:   "内存管理|GC|"
date:       2018-06-20 13:30:00
author:     "ZJF"
header-img: "img/post-bg-unix-linux.jpg"
catalog: false
tags:
    - JVM原理
---

Java和C之类语言相比,其中一点就是Java的内存是由虚拟机自动管理的,这为我们带来了便捷,但我们也需要去了解虚拟机是如何工作的,以便发生问题时可以有效的排查
除此之外了解JVM原理对于Java开发工程师也是一门必修课,刚毕业的话不需要全都掌握,但需要有个大致的了解,为以后的实战积累必要的基础..

## 运行时数据区域
程序计数器(Program Counter Register):当前线程所执行的字节码行号指示器,每个线程都有一个独立的程序计数器,是线程私有的,占用的内存空间也比较小
唯一一个在虚拟机规范中没有规定任何OutOfMemoryError的区域

Java虚拟机栈(Stacks):
1.线程私有的
2.生命周期与线程相同
线程的生命周期:
3.用来描述方法执行的内存模型,每个方法在执行时都会创建一个栈帧,用来存储局部变量表、方法出口等等
局部变量表存放了各种基本数据类型,对象引用以及returnAddress类型(一条字节码指令的地址),局部变量所需的空间会在编译器完成分配
* 每一个方法从调用到执行完成,对应着这个栈帧从入栈到出栈的过程

本地方法栈(Native Method Stack):
1.与虚拟机栈相似,为Native方法提供服务
2.对于实现没有强制规范,也有一些虚拟机将本地方法栈的实现合并进Java虚拟机栈的,这里就不过多介绍了

Java堆(Heap):
1.多个线程共享的
2.唯一目的就是存放对象实例
3.后面介绍GC主要就是在这个区域上进行垃圾数据回收的

方法区(Method Area):
1.多个线程共享的
2.存储虚拟机加载的类信息(字段、方法、接口等描述)、常量、静态变量,这些编译器编译后(程序运行之前)就有的信息

运行时常量池(RUntime Constant Pool)
1.方法区的一部分
2.在类加载之后将编译器生成的字面亮和符号引用放入这个区域(Specila运行期间也可以将新的常量放入该存储区域)

之外
直接内存(Direct Memory):
可以通过NIO的方式在某些场景下通过直接操作堆外内存提升性能,这块不常用


## 



```java
	
```

















