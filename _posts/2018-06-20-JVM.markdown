---
layout:     post
title:      "JVM小记(一)"
subtitle:   "内存管理|GC|"
date:       2018-06-20 13:30:00
author:     "ZJF"
header-img: "img/post-bg-unix-linux.jpg"
catalog: false
tags:
    - JVM原理
---
Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”,墙外面的人想进去,墙里面的人却想出来.---《深入理解Java虚拟机》

Java的内存是由虚拟机自动管理的,这为我们带来了便捷,但我们也需要去了解虚拟机是如何工作的,以便发生问题时可以有效的排查
## Java内存区域
首先介绍一下JVM运行时数据区域,也就是人们常说的Java内存模型,需要注意的是各个区域的功能主要是基于Java虚拟机的规范,不同的虚拟机实现会有不同,以及在物理存储介质上并没有这样的分区划分

`程序计数器`(Program Counter Register)
* 线程私有,存储当前线程所执行的字节码行号指示器,内存占用空间很小
* 唯一一个在虚拟机规范中没有规定任何OutOfMemoryError的区域
说得简单点就是记录各个线程的指令执行到哪了,在多线程的场景下,维护代码执行顺序的正确性

`Java虚拟机栈`(Stacks)
* 线程私有,存储Java方法执行的内存模型,生命周期与线程相同
* 方法从调用到执行完成,对应着栈帧从入栈到出栈
每个方法在执行时都会创建一个栈帧,里面存着储局部变量表以及其他一些数据,重点说一下局部变量表
局部变量表存放了各种基本数据类型,对象引用以及returnAddress类型(一条字节码指令的地址),我们常说的对象引用存在栈内就是说的这里,局部变量所需的空间会在编译器完成分配(确定)


本地方法栈(Native Method Stack)
1.与虚拟机栈相似,为Native方法提供服务
2.对于实现没有强制规范,也有一些虚拟机将本地方法栈的实现合并进Java虚拟机栈的,这里就不过多介绍了

Java堆(Heap):
1.多个线程共享的
2.唯一目的就是存放对象实例
3.后面介绍GC主要就是在这个区域上进行垃圾数据回收的

方法区(Method Area):
1.多个线程共享的
2.存储虚拟机加载的类信息(字段、方法、接口等描述)、常量、静态变量,这些编译器编译后(程序运行之前)就有的信息

运行时常量池(RUntime Constant Pool)
1.方法区的一部分
2.在类加载之后将编译器生成的字面亮和符号引用放入这个区域(Specila运行期间也可以将新的常量放入该存储区域)

之外
直接内存(Direct Memory):
可以通过NIO的方式在某些场景下通过直接操作堆外内存提升性能,这块不常用


## 



```java
	
```

















