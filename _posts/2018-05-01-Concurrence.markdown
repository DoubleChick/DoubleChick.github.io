---
layout:     post
title:      "Java并发笔记(一)"
subtitle:   "synchronized|valatile|原子性|可见性"
date:       2018-05-01 13:30:00
author:     "ZJF"
header-img: "img/post-bg-unix-linux.jpg"
catalog: false
tags:
    - Java核心技术
---
## 写在开头
Java的并发内容是Java基础知识的重要部分,看似很多人都懂的“并发”其实是有很多细节在里面的,前一阵子也拜读了Java并发编程实战一书,感觉知识量真的是饱和啊
想这里记录一些重要的知识内容,把吸收的并发知识梳理成体系

## 线程安全性
定义:当多个线程访问每个类,这个类始终都能表现出`正确的行为`,那么就成这个类是线程安全的
多线程的的应用程序在实际项目中非常常见,通常情况我们不会显式的使用Thread等类去启动新线程创造多线程场景,但像Servlet或基于Servlet的框架会在你写的代码的外层默认的为每个请求创建一个新线程,那么你写的代码自然就处在一个多线程的场景下了,因此需要关注安全性问题

这个不难理解,当一个线程一连串的行为还没执行完,另外一个线程就一脚插进来开始执行,毫无疑问会影响线程安全性,至于最后的结果是否真的偏离预期就要具体问题具体分析了.
这种由不恰当的执行时序而出现不正确的结果是一种非常重要的情况,比较正式的名称是:竞态条件(Race Condition)

## 原子性
64位操作!!!

存在线程安全性的代码(类)的种类有很多,再次就不一一列举了,我们讨论的重点的是如何让多线程条件下非安全的代码变得安全

## 加锁~
Java提供了一种内置的锁机制来支持原子性,即同步代码块,也就是我们编码中的synchronized关键字.

```java
synchronized(lock){
	//写在synchronized代码块中的代码,整体具备原子性
}
```
其中lock是一个对象实例的引用,
当synchronized关键字加载方法上面的时候就不会有lock参数了,这是代码块的锁就变成了调用该方法的对象实例,静态方法为Class对象.

## synchronized的性能
当一个线程获取到synchronized代码块的锁时,该线程对这段代码进行独占,其余线程若想访问这段代码,只能等着,直到锁施放为止,这期间不能进行其他的操作.
这会导致并发的性能很差,使程序编程不良并发程序(Poor Concurrency)

首先一种最直接简单的做法就是控制同步代码块的大小,将真正会引发竞态条件的代码片段进行同步,将一些对局部状态的修改等代码从synchronized代码块抽出,这样会一定程度上减少一些性能的耗费,不过要寻找合理或者最优的同步代码块大小,是不那么容易的,一般要结合业务需求,安全性,性能综合考虑,这就要具体问题具体分析了,后面我们也会介绍其他除synchronized代码块之外的其他同步机制.

## 可见性
可见性的正式定义我觉得很难描述,也不容理解,我理解中的可见性主要是针对变量(状态)的.
因为变量的修改操作在底层一般都是“读取-修改-再写入”的这么一系列操作
以上面介绍的自增操作为例,当读取的一个变量的值后,是无法观测到其他线程对这个值的`最新修改`的,所以很容易产生多个线程对同一变量的操作结果相互覆盖的过程.这种失效值的导致的错误是不可预期的.
除了这种相对容易发现的竞态条件之外,虚拟机基于性能的考虑对代码进行的指令重排序也会导致读线程对共享变量的不可见,这种情况分析起来就非常苦难了,


* 最简单的方式就是如果有变量(状态),在多个线程之间共享,那么就使用同步(不只是synchronized)手段

## valatile 变量
















