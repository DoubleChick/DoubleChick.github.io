---
layout:     post
title:      "ZDAL-分布式数据存储框架"
subtitle:   "数据拆分"
date:       2017-12-16 13:30:00
author:     "ZJF"
header-img: "img/post-bg-unix-linux.jpg"
catalog: false
tags:
    - 蚂蚁中间件
---

## 概念

JDBC(Java DataBase Connectivity)是一组由Java编写的类和接口集
* 封装了与多种数据库的连接实现,提供标准化的接口
* 通过JDBC访问数据库可以专注于SQL逻辑而不需要为每一个数据库创建一套连接程序

ZDAL是一个基于JDBC的`分布式`数据存储框架,结合一个问题概要的介绍一下ZDAL的功能

> ZDAL和ORM框架(iBatis、Hibernate等)的区别?

> ZDAL在JDBC的数据库连接基础之上`采用分布式架构`提供数据拆分、数据源弹性伸缩、流量分发等功能
来解决传统单库单表存储的`容量性能瓶颈`以及在海量吞吐场景下提供`更安全稳定的数据层服务`

> ORM框架主要使用元数据(XML中的声明)建立数据库记录与Java对象之间的映射关系,将对数据库记录的操作转化为对内存对象的操作

> 个人感觉ZDAL主要解决性能安全问题,ORM框架主要为生成SQL以及数据库记录以及内存对象转换提供便利,两者互不依赖可单独使用

本人在项目中使用的是 Sofa4 + ZDAL4 + iBatis 架构
本文主要介绍一下ZDAL的数据拆分功能及涉及到的相关概念

ZDAL架构图一览
![img](/img/in-post/zdal-architecture.jpg)

## 数据源配置&分库分表规则
在单库不分表的场景下,数据量的增大很容易产生数据库的性能问题
* 例如单表存储1000w记录,查询会非常耗时
* 数据太大也会对单台机器的容量产生压力,从而影响性能

通过数据拆分(本文均指水平拆分)可以解决上述问题,首先介绍ZDAL中数据源的配置

首先在common-dal bundle中通过Sofa标签声明JDBC的DataSouce实现类bkxxxDataSource
* 可以看出DataSouce实现类依赖应用数据源
* 使用方法:在业务代码中获取bkxxxDataSource或者将其注入到ORM框架中来对数据库进行操作
```xml
	<sofa:zdal-jdbc id="bkxxxDataSource">
		<!-- 应用数据源 -->
		<sofa:appDataSourceName value="bkxxxApplicationDataSource" />
	</sofa:zdal-jdbc>
```

应用数据源等配置写在{appname}-{environmentId}-{zone}-{version}-ds.xml文件下
必须严格按照格式及真实数据填写,ZDAL在不同环境运行时会根据各项属性值获取特定配置文件进行初始化
* appname 应用名 例如:bkxxx
* environmentId 当前所属环境(dev、stable等)
* zone LDC的zone标识、不同的zone对请求的路由规则不同、默认gz00
* version 版本号,可以没有

数据源配置文件内容如下:
首先声明应用名、环境标识、Zone标识等信息、以及系统的应用数据源列表(可以为多个)
```xml	
	<bean id="bkxxx" class="com.alipay.zdal.client.config.bean.ZdalAppBean">
		<property name="appName" value="bkxxx" />
		<property name="dbmode" value="stable" />
		<property name="idcName" value="gz00" />
		<property name="appDataSourceList">
			<list>
				<ref bean="bkxxxApplicationDataSource" />
			</list>
		</property>
	</bean>
```

`应用数据源`中依赖`物理数据源`以及`弹性数据源`
本应用中只做了分表策略,没有进行分库所以物理数据源只有一项,
分库场景下可以根据情况声明多个,路由规则后面会介绍
```xml
<bean id="bkxxxApplicationDataSource" class="com.alipay.zdal.client.config.bean.AppDataSourceBean">
		<property name="appDataSourceName" value="bkxxxApplicationDataSource" />
		<!-- 数据库类型 -->
		<property name="dataBaseType" value="MYSQL" />
		<!-- 发生跨zone sql时抛出异常 -->
		<property name="zoneError" value="EXCEPTION" />
		<!-- 分库分表规则 -->
		<property name="appRule" ref="bkxxxApplicationDataSourceRule" />
		<!-- 物理数据源列表 -->
		<property name="physicalDataSourceSet">
			<set>
				<ref bean="bkxxxDataSourcePhysics" />
			</set>
		</property>
		<!-- 弹性数据源配置 -->
		<property name="groupDataSourceRuleMap">
			<map>
				<entry key="group_0" value="bkxxx_ds:r10w10" />
			</map>
		</property>
	</bean>
```

`物理数据源`
```xml
<bean id="bkxxxDataSourcePhysics" class="com.alipay.zdal.client.config.bean.PhysicalDataSourceBean">
		<!-- 用户名、密码、连接数、超时时间等配置,此处略 -->
		<property name="logicDbNameSet">
			<set>
				<value><![CDATA[bkxxx_ds]]></value>
			</set>
		</property>
</bean>
```

应用数据源的规则
```xml
	<bean id="bkxxxApplicationDataSourceRule" class="com.alipay.zdal.rule.config.beans.AppRule" init-method="init">
		<property name="masterRule" ref="bkxxxApplicationDataSourceElasticRule" />
	</bean>
```

数据源规则列表,以table为当单位,真实场景需要将所有table加入tableRules中key为表名
```xml
<bean id="bkxxxApplicationDataSourceElasticRule" class="com.alipay.zdal.rule.config.beans.ShardRule">
		<property name="dbtype" value="MYSQL" />
		<property name="tableRules">
			<map>
				<entry key="bkxxx_transfer_detail" value-ref="bkxxx_transfer_detail_rule" />
			</map>
		</property>
</bean>
```
ZDAL支持以下四种分库分表结构
![img](/img/in-post/DepotsTableStructure.png)
本文中使用throughAIIDB结构分表

* 结合一个简单的例子看一下分库分表的具体配置
* 假设bkxxx_transfer_detail表中存储支付宝转账明细记录,字段aliPay_id存储支付宝id
* 现设计以aliPay_id为分表索引
* 分表规则为根据aliPay_id最后两位(00-99)将原表拆分成100张表

自定义静态方法来解析分表索引
```java
package com.mybank.bkxxx.common.dal.common;

public class ZDALRule {
    public static String parseTableIndexByAliPayId(String aliPayId) {
        return aliPayId.substring(aliPayId.length()-2, aliPayId.length());
    }
}
```

```xml
<bean id="bkxxx_transfer_detail_rule" class="com.alipay.zdal.rule.config.beans.TableRule" init-method="init">
		<property name="logicTableName" value="bkxxx_transfer_detail" />
		<!-- 表后缀 -->
		<property name="tbSuffix">
			<value><![CDATA[groovyThroughAllDBTableList:def list = [];(0..99).each{ i ->list.add("0"+"${i}".padLeft(3,"0") );}; return list;]]></value>
		</property>
		<!-- 库列表 -->
		<property name="dbIndexes">
			<value><![CDATA[bkxxx_ds]]></value>
		</property>
		<!-- 分表规则 -->
		<property name="tbRuleArray">
			<list>
				<value><![CDATA[return com.mybank.bkxxx.common.dal.common.ZDALRule.parseTableIndexByAliPayId(#aliPay_id#).padLeft(4,"0");]]></value>
			</list>
		</property>
		<!-- 分库规则 -->
		<property name="dbRuleList">
			<list>
				<value><![CDATA[ if(null != #id#) return 0;]]></value>
			</list>
		</property>
	</bean>
```

ZDAL的分布式Sequence等其他特性后续有心得再补充 ╮(￣▽￣"")╭